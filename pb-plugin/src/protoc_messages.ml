(* Generated by ocaml-pb-plugin *)

[@@@ocaml.warning "-30"] (* record labels reused *)

open Unsigned
module type TRANSPORT = sig end
type double = float
let from_opt ~default = function Some v -> v | None -> default
let opt_map f = function Some v -> Some (f v) | None -> None
let rassoc y l = fst (List.find (fun (_,y') -> y = y') l)

module Types_ =
struct

  module DescriptorProto = (val Pb.message "DescriptorProto")
  module ServiceOptions = (val Pb.message "ServiceOptions")
  module Location = (val Pb.message "Location")
  module File = (val Pb.message "File")
  module FileDescriptorSet = (val Pb.message "FileDescriptorSet")
  module EnumOptions = (val Pb.message "EnumOptions")
  module MethodDescriptorProto = (val Pb.message "MethodDescriptorProto")
  module ServiceDescriptorProto = (val Pb.message "ServiceDescriptorProto")
  module ReservedRange = (val Pb.message "ReservedRange")
  module OneofOptions = (val Pb.message "OneofOptions")
  module CodeGeneratorResponse = (val Pb.message "CodeGeneratorResponse")
  module GeneratedCodeInfo = (val Pb.message "GeneratedCodeInfo")
  module CodeGeneratorRequest = (val Pb.message "CodeGeneratorRequest")
  module EnumDescriptorProto = (val Pb.message "EnumDescriptorProto")
  module FileOptions = (val Pb.message "FileOptions")
  module Annotation = (val Pb.message "Annotation")
  module OneofDescriptorProto = (val Pb.message "OneofDescriptorProto")
  module EnumValueDescriptorProto =
  (val Pb.message "EnumValueDescriptorProto")
  module FieldDescriptorProto = (val Pb.message "FieldDescriptorProto")
  module SourceCodeInfo = (val Pb.message "SourceCodeInfo")
  module FieldOptions = (val Pb.message "FieldOptions")
  module EnumValueOptions = (val Pb.message "EnumValueOptions")
  module UninterpretedOption = (val Pb.message "UninterpretedOption")
  module ExtensionRange = (val Pb.message "ExtensionRange")
  module MessageOptions = (val Pb.message "MessageOptions")
  module MethodOptions = (val Pb.message "MethodOptions")
  module FileDescriptorProto = (val Pb.message "FileDescriptorProto")
  module NamePart = (val Pb.message "NamePart")
  module Version = (val Pb.message "Version")
  module OptimizeMode = (val Pb.enum "OptimizeMode")
  module Label = (val Pb.enum "Label")
  module Type = (val Pb.enum "Type")
  module JSType = (val Pb.enum "JSType")
  module IdempotencyLevel = (val Pb.enum "IdempotencyLevel")
  module CType = (val Pb.enum "CType")
  module OptimizeMode__constants =
  struct
   let speed = OptimizeMode.constant "SPEED" 1l
   let code_size = OptimizeMode.constant "CODE_SIZE" 2l
   let lite_runtime = OptimizeMode.constant "LITE_RUNTIME" 3l
  end
  
  module Label__constants =
  struct
   let label_optional = Label.constant "LABEL_OPTIONAL" 1l
   let label_required = Label.constant "LABEL_REQUIRED" 2l
   let label_repeated = Label.constant "LABEL_REPEATED" 3l
  end
  
  module Type__constants =
  struct
   let type_double = Type.constant "TYPE_DOUBLE" 1l
   let type_float = Type.constant "TYPE_FLOAT" 2l
   let type_int64 = Type.constant "TYPE_INT64" 3l
   let type_uint64 = Type.constant "TYPE_UINT64" 4l
   let type_int32 = Type.constant "TYPE_INT32" 5l
   let type_fixed64 = Type.constant "TYPE_FIXED64" 6l
   let type_fixed32 = Type.constant "TYPE_FIXED32" 7l
   let type_bool = Type.constant "TYPE_BOOL" 8l
   let type_string = Type.constant "TYPE_STRING" 9l
   let type_group = Type.constant "TYPE_GROUP" 10l
   let type_message = Type.constant "TYPE_MESSAGE" 11l
   let type_bytes = Type.constant "TYPE_BYTES" 12l
   let type_uint32 = Type.constant "TYPE_UINT32" 13l
   let type_enum = Type.constant "TYPE_ENUM" 14l
   let type_sfixed32 = Type.constant "TYPE_SFIXED32" 15l
   let type_sfixed64 = Type.constant "TYPE_SFIXED64" 16l
   let type_sint32 = Type.constant "TYPE_SINT32" 17l
   let type_sint64 = Type.constant "TYPE_SINT64" 18l
  end
  
  module JSType__constants =
  struct
   let js_normal = JSType.constant "JS_NORMAL" 0l
   let js_string = JSType.constant "JS_STRING" 1l
   let js_number = JSType.constant "JS_NUMBER" 2l
  end
  
  module IdempotencyLevel__constants =
  struct
   let idempotency_unknown = IdempotencyLevel.constant "IDEMPOTENCY_UNKNOWN"
  0l
   let no_side_effects = IdempotencyLevel.constant "NO_SIDE_EFFECTS" 1l
   let idempotent = IdempotencyLevel.constant "IDEMPOTENT" 2l
  end
  
  module CType__constants =
  struct
   let string = CType.constant "STRING" 0l
   let cord = CType.constant "CORD" 1l
   let string_piece = CType.constant "STRING_PIECE" 2l
  end
  
  module Fields__DescriptorProto = struct
   module T = DescriptorProto
  
   let name            = T.optional Pb.string "name" 1
   let field           = T.repeated (Pb.msg FieldDescriptorProto.t) "field" 2
   let extension       =
     T.repeated (Pb.msg FieldDescriptorProto.t) "extension" 6
   let nested_type     =
     T.repeated (Pb.msg DescriptorProto.t) "nested_type" 3
   let enum_type       =
     T.repeated (Pb.msg EnumDescriptorProto.t) "enum_type" 4
   let extension_range =
     T.repeated (Pb.msg ExtensionRange.t) "extension_range" 5
   let oneof_decl      =
     T.repeated (Pb.msg OneofDescriptorProto.t) "oneof_decl" 8
   let options         = T.optional (Pb.msg MessageOptions.t) "options" 7
   let reserved_range  =
     T.repeated (Pb.msg ReservedRange.t) "reserved_range" 9
   let reserved_name   = T.repeated Pb.string "reserved_name" 10
  
  end
  
  
  module Fields__ServiceOptions = struct
   module T = ServiceOptions
  
   let deprecated           =
     T.optional ~default:false Pb.bool "deprecated" 33
   let uninterpreted_option =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__Location = struct
   module T = Location
  
   let path                      = T.repeated Pb.int32 "path" 1
   let span                      = T.repeated Pb.int32 "span" 2
   let leading_comments          = T.optional Pb.string "leading_comments" 3
   let trailing_comments         = T.optional Pb.string "trailing_comments" 4
   let leading_detached_comments =
     T.repeated Pb.string "leading_detached_comments" 6
  
  end
  
  
  module Fields__File = struct
   module T = File
  
   let name            = T.optional Pb.string "name" 1
   let insertion_point = T.optional Pb.string "insertion_point" 2
   let content         = T.optional Pb.string "content" 15
  
  end
  
  
  module Fields__FileDescriptorSet = struct
   module T = FileDescriptorSet
  
   let file = T.repeated (Pb.msg FileDescriptorProto.t) "file" 1
  
  end
  
  
  module Fields__EnumOptions = struct
   module T = EnumOptions
  
   let allow_alias          = T.optional Pb.bool "allow_alias" 2
   let deprecated           =
     T.optional ~default:false Pb.bool "deprecated" 3
   let uninterpreted_option =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__MethodDescriptorProto = struct
   module T = MethodDescriptorProto
  
   let name             = T.optional Pb.string "name" 1
   let input_type       = T.optional Pb.string "input_type" 2
   let output_type      = T.optional Pb.string "output_type" 3
   let options          = T.optional (Pb.msg MethodOptions.t) "options" 4
   let client_streaming =
     T.optional ~default:false Pb.bool "client_streaming" 5
   let server_streaming =
     T.optional ~default:false Pb.bool "server_streaming" 6
  
  end
  
  
  module Fields__ServiceDescriptorProto = struct
   module T = ServiceDescriptorProto
  
   let name    = T.optional Pb.string "name" 1
   let method_  = T.repeated (Pb.msg MethodDescriptorProto.t) "method" 2
   let options = T.optional (Pb.msg ServiceOptions.t) "options" 3
  
  end
  
  
  module Fields__ReservedRange = struct
   module T = ReservedRange
  
   let start = T.optional Pb.int32 "start" 1
   let end_   = T.optional Pb.int32 "end" 2
  
  end
  
  
  module Fields__OneofOptions = struct
   module T = OneofOptions
  
   let uninterpreted_option =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__CodeGeneratorResponse = struct
   module T = CodeGeneratorResponse
  
   let error = T.optional Pb.string "error" 1
   let file  = T.repeated (Pb.msg File.t) "file" 15
  
  end
  
  
  module Fields__GeneratedCodeInfo = struct
   module T = GeneratedCodeInfo
  
   let annotation = T.repeated (Pb.msg Annotation.t) "annotation" 1
  
  end
  
  
  module Fields__CodeGeneratorRequest = struct
   module T = CodeGeneratorRequest
  
   let file_to_generate = T.repeated Pb.string "file_to_generate" 1
   let parameter        = T.optional Pb.string "parameter" 2
   let proto_file       =
     T.repeated (Pb.msg FileDescriptorProto.t) "proto_file" 15
   let compiler_version = T.optional (Pb.msg Version.t) "compiler_version" 3
  
  end
  
  
  module Fields__EnumDescriptorProto = struct
   module T = EnumDescriptorProto
  
   let name    = T.optional Pb.string "name" 1
   let value   = T.repeated (Pb.msg EnumValueDescriptorProto.t) "value" 2
   let options = T.optional (Pb.msg EnumOptions.t) "options" 3
  
  end
  
  
  module Fields__FileOptions = struct
   module T = FileOptions
  
   let java_package                  = T.optional Pb.string "java_package" 1
   let java_outer_classname          =
     T.optional Pb.string "java_outer_classname" 8
   let java_multiple_files           =
     T.optional ~default:false Pb.bool "java_multiple_files" 10
   let java_generate_equals_and_hash =
     T.optional Pb.bool "java_generate_equals_and_hash" 20
   let java_string_check_utf8        =
     T.optional ~default:false Pb.bool "java_string_check_utf8" 27
   let optimize_for                  =
     T.optional ~default:OptimizeMode__constants.speed OptimizeMode.t
     "optimize_for" 9
   let go_package                    = T.optional Pb.string "go_package" 11
   let cc_generic_services           =
     T.optional ~default:false Pb.bool "cc_generic_services" 16
   let java_generic_services         =
     T.optional ~default:false Pb.bool "java_generic_services" 17
   let py_generic_services           =
     T.optional ~default:false Pb.bool "py_generic_services" 18
   let deprecated                    =
     T.optional ~default:false Pb.bool "deprecated" 23
   let cc_enable_arenas              =
     T.optional ~default:false Pb.bool "cc_enable_arenas" 31
   let objc_class_prefix             =
     T.optional Pb.string "objc_class_prefix" 36
   let csharp_namespace              =
     T.optional Pb.string "csharp_namespace" 37
   let swift_prefix                  = T.optional Pb.string "swift_prefix" 39
   let uninterpreted_option          =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__Annotation = struct
   module T = Annotation
  
   let path        = T.repeated Pb.int32 "path" 1
   let source_file = T.optional Pb.string "source_file" 2
   let begin_       = T.optional Pb.int32 "begin" 3
   let end_         = T.optional Pb.int32 "end" 4
  
  end
  
  
  module Fields__OneofDescriptorProto = struct
   module T = OneofDescriptorProto
  
   let name    = T.optional Pb.string "name" 1
   let options = T.optional (Pb.msg OneofOptions.t) "options" 2
  
  end
  
  
  module Fields__EnumValueDescriptorProto = struct
   module T = EnumValueDescriptorProto
  
   let name    = T.optional Pb.string "name" 1
   let number  = T.optional Pb.int32 "number" 2
   let options = T.optional (Pb.msg EnumValueOptions.t) "options" 3
  
  end
  
  
  module Fields__FieldDescriptorProto = struct
   module T = FieldDescriptorProto
  
   let name          = T.optional Pb.string "name" 1
   let number        = T.optional Pb.int32 "number" 3
   let label         = T.optional Label.t "label" 4
   let type_          = T.optional Type.t "type" 5
   let type_name     = T.optional Pb.string "type_name" 6
   let extendee      = T.optional Pb.string "extendee" 2
   let default_value = T.optional Pb.string "default_value" 7
   let oneof_index   = T.optional Pb.int32 "oneof_index" 9
   let json_name     = T.optional Pb.string "json_name" 10
   let options       = T.optional (Pb.msg FieldOptions.t) "options" 8
  
  end
  
  
  module Fields__SourceCodeInfo = struct
   module T = SourceCodeInfo
  
   let location = T.repeated (Pb.msg Location.t) "location" 1
  
  end
  
  
  module Fields__FieldOptions = struct
   module T = FieldOptions
  
   let ctype                =
     T.optional ~default:CType__constants.string CType.t "ctype" 1
   let packed               = T.optional Pb.bool "packed" 2
   let jstype               =
     T.optional ~default:JSType__constants.js_normal JSType.t "jstype" 6
   let lazy_                 = T.optional ~default:false Pb.bool "lazy" 5
   let deprecated           =
     T.optional ~default:false Pb.bool "deprecated" 3
   let weak                 = T.optional ~default:false Pb.bool "weak" 10
   let uninterpreted_option =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__EnumValueOptions = struct
   module T = EnumValueOptions
  
   let deprecated           =
     T.optional ~default:false Pb.bool "deprecated" 1
   let uninterpreted_option =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__UninterpretedOption = struct
   module T = UninterpretedOption
  
   let name               = T.repeated (Pb.msg NamePart.t) "name" 2
   let identifier_value   = T.optional Pb.string "identifier_value" 3
   let positive_int_value = T.optional Pb.uint64 "positive_int_value" 4
   let negative_int_value = T.optional Pb.int64 "negative_int_value" 5
   let double_value       = T.optional Pb.double "double_value" 6
   let string_value       = T.optional Pb.bytes "string_value" 7
   let aggregate_value    = T.optional Pb.string "aggregate_value" 8
  
  end
  
  
  module Fields__ExtensionRange = struct
   module T = ExtensionRange
  
   let start = T.optional Pb.int32 "start" 1
   let end_   = T.optional Pb.int32 "end" 2
  
  end
  
  
  module Fields__MessageOptions = struct
   module T = MessageOptions
  
   let message_set_wire_format         =
     T.optional ~default:false Pb.bool "message_set_wire_format" 1
   let no_standard_descriptor_accessor =
     T.optional ~default:false Pb.bool "no_standard_descriptor_accessor" 2
   let deprecated                      =
     T.optional ~default:false Pb.bool "deprecated" 3
   let map_entry                       = T.optional Pb.bool "map_entry" 7
   let uninterpreted_option            =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__MethodOptions = struct
   module T = MethodOptions
  
   let deprecated           =
     T.optional ~default:false Pb.bool "deprecated" 33
   let idempotency_level    =
     T.optional ~default:IdempotencyLevel__constants.idempotency_unknown
     IdempotencyLevel.t "idempotency_level" 34
   let uninterpreted_option =
     T.repeated (Pb.msg UninterpretedOption.t) "uninterpreted_option" 999
  
  end
  
  
  module Fields__FileDescriptorProto = struct
   module T = FileDescriptorProto
  
   let name              = T.optional Pb.string "name" 1
   let package           = T.optional Pb.string "package" 2
   let dependency        = T.repeated Pb.string "dependency" 3
   let public_dependency = T.repeated Pb.int32 "public_dependency" 10
   let weak_dependency   = T.repeated Pb.int32 "weak_dependency" 11
   let message_type      =
     T.repeated (Pb.msg DescriptorProto.t) "message_type" 4
   let enum_type         =
     T.repeated (Pb.msg EnumDescriptorProto.t) "enum_type" 5
   let service           =
     T.repeated (Pb.msg ServiceDescriptorProto.t) "service" 6
   let extension         =
     T.repeated (Pb.msg FieldDescriptorProto.t) "extension" 7
   let options           = T.optional (Pb.msg FileOptions.t) "options" 8
   let source_code_info  =
     T.optional (Pb.msg SourceCodeInfo.t) "source_code_info" 9
   let syntax            = T.optional Pb.string "syntax" 12
  
  end
  
  
  module Fields__NamePart = struct
   module T = NamePart
  
   let name_part    = T.required Pb.string "name_part" 1
   let is_extension = T.required Pb.bool "is_extension" 2
  
  end
  
  
  module Fields__Version = struct
   module T = Version
  
   let major  = T.optional Pb.int32 "major" 1
   let minor  = T.optional Pb.int32 "minor" 2
   let patch  = T.optional Pb.int32 "patch" 3
   let suffix = T.optional Pb.string "suffix" 4
  
  end
  
  
  type s_DescriptorProto = {
    reserved_name: string list;
    reserved_range: s_ReservedRange list;
    options: s_MessageOptions option;
    oneof_decl: s_OneofDescriptorProto list;
    extension_range: s_ExtensionRange list;
    enum_type: s_EnumDescriptorProto list;
    nested_type: s_DescriptorProto list;
    extension: s_FieldDescriptorProto list;
    field: s_FieldDescriptorProto list;
    name: string option;
  }
  and s_ServiceOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    deprecated: bool;
  }
  and s_Location = {
    leading_detached_comments: string list;
    trailing_comments: string option;
    leading_comments: string option;
    span: int32 list;
    path: int32 list;
  }
  and s_File = {
    content: string option;
    insertion_point: string option;
    name: string option;
  }
  and s_FileDescriptorSet = {
    file: s_FileDescriptorProto list;
  }
  and s_EnumOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    deprecated: bool;
    allow_alias: bool option;
  }
  and s_MethodDescriptorProto = {
    server_streaming: bool;
    client_streaming: bool;
    options: s_MethodOptions option;
    output_type: string option;
    input_type: string option;
    name: string option;
  }
  and s_ServiceDescriptorProto = {
    options: s_ServiceOptions option;
    method_: s_MethodDescriptorProto list;
    name: string option;
  }
  and s_ReservedRange = {
    end_: int32 option;
    start: int32 option;
  }
  and s_OneofOptions = {
    uninterpreted_option: s_UninterpretedOption list;
  }
  and s_CodeGeneratorResponse = {
    file: s_File list;
    error: string option;
  }
  and s_GeneratedCodeInfo = {
    annotation: s_Annotation list;
  }
  and s_CodeGeneratorRequest = {
    compiler_version: s_Version option;
    proto_file: s_FileDescriptorProto list;
    parameter: string option;
    file_to_generate: string list;
  }
  and s_EnumDescriptorProto = {
    options: s_EnumOptions option;
    value: s_EnumValueDescriptorProto list;
    name: string option;
  }
  and s_FileOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    swift_prefix: string option;
    csharp_namespace: string option;
    objc_class_prefix: string option;
    cc_enable_arenas: bool;
    deprecated: bool;
    py_generic_services: bool;
    java_generic_services: bool;
    cc_generic_services: bool;
    go_package: string option;
    optimize_for: OptimizeMode.e Pb.enum;
    java_string_check_utf8: bool;
    java_generate_equals_and_hash: bool option;
    java_multiple_files: bool;
    java_outer_classname: string option;
    java_package: string option;
  }
  and s_Annotation = {
    end_: int32 option;
    begin_: int32 option;
    source_file: string option;
    path: int32 list;
  }
  and s_OneofDescriptorProto = {
    options: s_OneofOptions option;
    name: string option;
  }
  and s_EnumValueDescriptorProto = {
    options: s_EnumValueOptions option;
    number: int32 option;
    name: string option;
  }
  and s_FieldDescriptorProto = {
    options: s_FieldOptions option;
    json_name: string option;
    oneof_index: int32 option;
    default_value: string option;
    extendee: string option;
    type_name: string option;
    type_: Type.e Pb.enum option;
    label: Label.e Pb.enum option;
    number: int32 option;
    name: string option;
  }
  and s_SourceCodeInfo = {
    location: s_Location list;
  }
  and s_FieldOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    weak: bool;
    deprecated: bool;
    lazy_: bool;
    jstype: JSType.e Pb.enum;
    packed: bool option;
    ctype: CType.e Pb.enum;
  }
  and s_EnumValueOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    deprecated: bool;
  }
  and s_UninterpretedOption = {
    aggregate_value: string option;
    string_value: Bytes.t option;
    double_value: double option;
    negative_int_value: int64 option;
    positive_int_value: uint64 option;
    identifier_value: string option;
    name: s_NamePart list;
  }
  and s_ExtensionRange = {
    end_: int32 option;
    start: int32 option;
  }
  and s_MessageOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    map_entry: bool option;
    deprecated: bool;
    no_standard_descriptor_accessor: bool;
    message_set_wire_format: bool;
  }
  and s_MethodOptions = {
    uninterpreted_option: s_UninterpretedOption list;
    idempotency_level: IdempotencyLevel.e Pb.enum;
    deprecated: bool;
  }
  and s_FileDescriptorProto = {
    syntax: string option;
    source_code_info: s_SourceCodeInfo option;
    options: s_FileOptions option;
    extension: s_FieldDescriptorProto list;
    service: s_ServiceDescriptorProto list;
    enum_type: s_EnumDescriptorProto list;
    message_type: s_DescriptorProto list;
    weak_dependency: int32 list;
    public_dependency: int32 list;
    dependency: string list;
    package: string option;
    name: string option;
  }
  and s_NamePart = {
    is_extension: bool;
    name_part: string;
  }
  and s_Version = {
    suffix: string option;
    patch: int32 option;
    minor: int32 option;
    major: int32 option;
  }
  let rec extract_DescriptorProto _msg = Fields__DescriptorProto.(({
    name = Pb.getf _msg name;
    field = List.map extract_FieldDescriptorProto (Pb.getf _msg field);
    extension =
    List.map extract_FieldDescriptorProto (Pb.getf _msg extension);
    nested_type = List.map extract_DescriptorProto (Pb.getf _msg nested_type);
    enum_type = List.map extract_EnumDescriptorProto (Pb.getf _msg enum_type);
    extension_range =
    List.map extract_ExtensionRange (Pb.getf _msg extension_range);
    oneof_decl =
    List.map extract_OneofDescriptorProto (Pb.getf _msg oneof_decl);
    options = opt_map extract_MessageOptions (Pb.getf _msg options);
    reserved_range =
    List.map extract_ReservedRange (Pb.getf _msg reserved_range);
    reserved_name = Pb.getf _msg reserved_name;
  } : s_DescriptorProto))
  and extract_ServiceOptions _msg = Fields__ServiceOptions.(({
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_ServiceOptions))
  and extract_Location _msg = Fields__Location.(({
    path = Pb.getf _msg path;
    span = Pb.getf _msg span;
    leading_comments = Pb.getf _msg leading_comments;
    trailing_comments = Pb.getf _msg trailing_comments;
    leading_detached_comments = Pb.getf _msg leading_detached_comments;
  } : s_Location))
  and extract_File _msg = Fields__File.(({
    name = Pb.getf _msg name;
    insertion_point = Pb.getf _msg insertion_point;
    content = Pb.getf _msg content;
  } : s_File))
  and extract_FileDescriptorSet _msg = Fields__FileDescriptorSet.(({
    file = List.map extract_FileDescriptorProto (Pb.getf _msg file);
  } : s_FileDescriptorSet))
  and extract_EnumOptions _msg = Fields__EnumOptions.(({
    allow_alias = Pb.getf _msg allow_alias;
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_EnumOptions))
  and extract_MethodDescriptorProto _msg = Fields__MethodDescriptorProto.(({
    name = Pb.getf _msg name;
    input_type = Pb.getf _msg input_type;
    output_type = Pb.getf _msg output_type;
    options = opt_map extract_MethodOptions (Pb.getf _msg options);
    client_streaming =
    from_opt ~default:false (Pb.getf _msg client_streaming);
    server_streaming =
    from_opt ~default:false (Pb.getf _msg server_streaming);
  } : s_MethodDescriptorProto))
  and extract_ServiceDescriptorProto _msg =
  Fields__ServiceDescriptorProto.(({
    name = Pb.getf _msg name;
    method_ = List.map extract_MethodDescriptorProto (Pb.getf _msg method_);
    options = opt_map extract_ServiceOptions (Pb.getf _msg options);
  } : s_ServiceDescriptorProto))
  and extract_ReservedRange _msg = Fields__ReservedRange.(({
    start = Pb.getf _msg start;
    end_ = Pb.getf _msg end_;
  } : s_ReservedRange))
  and extract_OneofOptions _msg = Fields__OneofOptions.(({
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_OneofOptions))
  and extract_CodeGeneratorResponse _msg = Fields__CodeGeneratorResponse.(({
    error = Pb.getf _msg error;
    file = List.map extract_File (Pb.getf _msg file);
  } : s_CodeGeneratorResponse))
  and extract_GeneratedCodeInfo _msg = Fields__GeneratedCodeInfo.(({
    annotation = List.map extract_Annotation (Pb.getf _msg annotation);
  } : s_GeneratedCodeInfo))
  and extract_CodeGeneratorRequest _msg = Fields__CodeGeneratorRequest.(({
    file_to_generate = Pb.getf _msg file_to_generate;
    parameter = Pb.getf _msg parameter;
    proto_file =
    List.map extract_FileDescriptorProto (Pb.getf _msg proto_file);
    compiler_version =
    opt_map extract_Version (Pb.getf _msg compiler_version);
  } : s_CodeGeneratorRequest))
  and extract_EnumDescriptorProto _msg = Fields__EnumDescriptorProto.(({
    name = Pb.getf _msg name;
    value = List.map extract_EnumValueDescriptorProto (Pb.getf _msg value);
    options = opt_map extract_EnumOptions (Pb.getf _msg options);
  } : s_EnumDescriptorProto))
  and extract_FileOptions _msg = Fields__FileOptions.(({
    java_package = Pb.getf _msg java_package;
    java_outer_classname = Pb.getf _msg java_outer_classname;
    java_multiple_files =
    from_opt ~default:false (Pb.getf _msg java_multiple_files);
    java_generate_equals_and_hash =
    Pb.getf _msg java_generate_equals_and_hash;
    java_string_check_utf8 =
    from_opt ~default:false (Pb.getf _msg java_string_check_utf8);
    optimize_for =
    from_opt ~default:OptimizeMode__constants.speed (Pb.getf _msg
    optimize_for);
    go_package = Pb.getf _msg go_package;
    cc_generic_services =
    from_opt ~default:false (Pb.getf _msg cc_generic_services);
    java_generic_services =
    from_opt ~default:false (Pb.getf _msg java_generic_services);
    py_generic_services =
    from_opt ~default:false (Pb.getf _msg py_generic_services);
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    cc_enable_arenas =
    from_opt ~default:false (Pb.getf _msg cc_enable_arenas);
    objc_class_prefix = Pb.getf _msg objc_class_prefix;
    csharp_namespace = Pb.getf _msg csharp_namespace;
    swift_prefix = Pb.getf _msg swift_prefix;
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_FileOptions))
  and extract_Annotation _msg = Fields__Annotation.(({
    path = Pb.getf _msg path;
    source_file = Pb.getf _msg source_file;
    begin_ = Pb.getf _msg begin_;
    end_ = Pb.getf _msg end_;
  } : s_Annotation))
  and extract_OneofDescriptorProto _msg = Fields__OneofDescriptorProto.(({
    name = Pb.getf _msg name;
    options = opt_map extract_OneofOptions (Pb.getf _msg options);
  } : s_OneofDescriptorProto))
  and extract_EnumValueDescriptorProto _msg =
  Fields__EnumValueDescriptorProto.(({
    name = Pb.getf _msg name;
    number = Pb.getf _msg number;
    options = opt_map extract_EnumValueOptions (Pb.getf _msg options);
  } : s_EnumValueDescriptorProto))
  and extract_FieldDescriptorProto _msg = Fields__FieldDescriptorProto.(({
    name = Pb.getf _msg name;
    number = Pb.getf _msg number;
    label = Pb.getf _msg label;
    type_ = Pb.getf _msg type_;
    type_name = Pb.getf _msg type_name;
    extendee = Pb.getf _msg extendee;
    default_value = Pb.getf _msg default_value;
    oneof_index = Pb.getf _msg oneof_index;
    json_name = Pb.getf _msg json_name;
    options = opt_map extract_FieldOptions (Pb.getf _msg options);
  } : s_FieldDescriptorProto))
  and extract_SourceCodeInfo _msg = Fields__SourceCodeInfo.(({
    location = List.map extract_Location (Pb.getf _msg location);
  } : s_SourceCodeInfo))
  and extract_FieldOptions _msg = Fields__FieldOptions.(({
    ctype = from_opt ~default:CType__constants.string (Pb.getf _msg ctype);
    packed = Pb.getf _msg packed;
    jstype =
    from_opt ~default:JSType__constants.js_normal (Pb.getf _msg jstype);
    lazy_ = from_opt ~default:false (Pb.getf _msg lazy_);
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    weak = from_opt ~default:false (Pb.getf _msg weak);
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_FieldOptions))
  and extract_EnumValueOptions _msg = Fields__EnumValueOptions.(({
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_EnumValueOptions))
  and extract_UninterpretedOption _msg = Fields__UninterpretedOption.(({
    name = List.map extract_NamePart (Pb.getf _msg name);
    identifier_value = Pb.getf _msg identifier_value;
    positive_int_value = Pb.getf _msg positive_int_value;
    negative_int_value = Pb.getf _msg negative_int_value;
    double_value = Pb.getf _msg double_value;
    string_value = Pb.getf _msg string_value;
    aggregate_value = Pb.getf _msg aggregate_value;
  } : s_UninterpretedOption))
  and extract_ExtensionRange _msg = Fields__ExtensionRange.(({
    start = Pb.getf _msg start;
    end_ = Pb.getf _msg end_;
  } : s_ExtensionRange))
  and extract_MessageOptions _msg = Fields__MessageOptions.(({
    message_set_wire_format =
    from_opt ~default:false (Pb.getf _msg message_set_wire_format);
    no_standard_descriptor_accessor =
    from_opt ~default:false (Pb.getf _msg no_standard_descriptor_accessor);
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    map_entry = Pb.getf _msg map_entry;
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_MessageOptions))
  and extract_MethodOptions _msg = Fields__MethodOptions.(({
    deprecated = from_opt ~default:false (Pb.getf _msg deprecated);
    idempotency_level =
    from_opt ~default:IdempotencyLevel__constants.idempotency_unknown
    (Pb.getf _msg idempotency_level);
    uninterpreted_option =
    List.map extract_UninterpretedOption (Pb.getf _msg uninterpreted_option);
  } : s_MethodOptions))
  and extract_FileDescriptorProto _msg = Fields__FileDescriptorProto.(({
    name = Pb.getf _msg name;
    package = Pb.getf _msg package;
    dependency = Pb.getf _msg dependency;
    public_dependency = Pb.getf _msg public_dependency;
    weak_dependency = Pb.getf _msg weak_dependency;
    message_type =
    List.map extract_DescriptorProto (Pb.getf _msg message_type);
    enum_type = List.map extract_EnumDescriptorProto (Pb.getf _msg enum_type);
    service = List.map extract_ServiceDescriptorProto (Pb.getf _msg service);
    extension =
    List.map extract_FieldDescriptorProto (Pb.getf _msg extension);
    options = opt_map extract_FileOptions (Pb.getf _msg options);
    source_code_info =
    opt_map extract_SourceCodeInfo (Pb.getf _msg source_code_info);
    syntax = Pb.getf _msg syntax;
  } : s_FileDescriptorProto))
  and extract_NamePart _msg = Fields__NamePart.(({
    name_part = Pb.getf _msg name_part;
    is_extension = Pb.getf _msg is_extension;
  } : s_NamePart))
  and extract_Version _msg = Fields__Version.(({
    major = Pb.getf _msg major;
    minor = Pb.getf _msg minor;
    patch = Pb.getf _msg patch;
    suffix = Pb.getf _msg suffix;
  } : s_Version))
end

module DescriptorProto = struct
 include Types_.Fields__DescriptorProto

 type s = Types_.s_DescriptorProto = {
   reserved_name: string list;
   reserved_range: Types_.s_ReservedRange list;
   options: Types_.s_MessageOptions option;
   oneof_decl: Types_.s_OneofDescriptorProto list;
   extension_range: Types_.s_ExtensionRange list;
   enum_type: Types_.s_EnumDescriptorProto list;
   nested_type: Types_.s_DescriptorProto list;
   extension: Types_.s_FieldDescriptorProto list;
   field: Types_.s_FieldDescriptorProto list;
   name: string option;
 }

 let extract = Types_.extract_DescriptorProto

 let mk ~reserved_name:_local0 ~reserved_range:_local1 ?options:_local2
     ~oneof_decl:_local3 ~extension_range:_local4 ~enum_type:_local5
     ~nested_type:_local6 ~extension:_local7 ~field:_local8 ?name:_local9  ()
     =
   let _msg = Pb.create T.t in
   Pb.setf _msg reserved_name _local0;
   Pb.setf _msg reserved_range _local1;
   Pb.setf _msg options _local2;
   Pb.setf _msg oneof_decl _local3;
   Pb.setf _msg extension_range _local4;
   Pb.setf _msg enum_type _local5;
   Pb.setf _msg nested_type _local6;
   Pb.setf _msg extension _local7;
   Pb.setf _msg field _local8;
   Pb.setf _msg name _local9;
   _msg
end

module ServiceOptions = struct
 include Types_.Fields__ServiceOptions

 type s = Types_.s_ServiceOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   deprecated: bool;
 }

 let extract = Types_.extract_ServiceOptions

 let mk ~uninterpreted_option:_local0 ?deprecated:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg deprecated _local1;
   _msg
end

module Location = struct
 include Types_.Fields__Location

 type s = Types_.s_Location = {
   leading_detached_comments: string list;
   trailing_comments: string option;
   leading_comments: string option;
   span: int32 list;
   path: int32 list;
 }

 let extract = Types_.extract_Location

 let mk ~leading_detached_comments:_local0 ?trailing_comments:_local1
     ?leading_comments:_local2 ~span:_local3 ~path:_local4  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg leading_detached_comments _local0;
   Pb.setf _msg trailing_comments _local1;
   Pb.setf _msg leading_comments _local2;
   Pb.setf _msg span _local3;
   Pb.setf _msg path _local4;
   _msg
end

module File = struct
 include Types_.Fields__File

 type s = Types_.s_File = {
   content: string option;
   insertion_point: string option;
   name: string option;
 }

 let extract = Types_.extract_File

 let mk ?content:_local0 ?insertion_point:_local1 ?name:_local2  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg content _local0;
   Pb.setf _msg insertion_point _local1;
   Pb.setf _msg name _local2;
   _msg
end

module FileDescriptorSet = struct
 include Types_.Fields__FileDescriptorSet

 type s = Types_.s_FileDescriptorSet = {
   file: Types_.s_FileDescriptorProto list;
 }

 let extract = Types_.extract_FileDescriptorSet

 let mk ~file:_local0  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg file _local0;
   _msg
end

module EnumOptions = struct
 include Types_.Fields__EnumOptions

 type s = Types_.s_EnumOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   deprecated: bool;
   allow_alias: bool option;
 }

 let extract = Types_.extract_EnumOptions

 let mk ~uninterpreted_option:_local0 ?deprecated:_local1
     ?allow_alias:_local2  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg deprecated _local1;
   Pb.setf _msg allow_alias _local2;
   _msg
end

module MethodDescriptorProto = struct
 include Types_.Fields__MethodDescriptorProto

 type s = Types_.s_MethodDescriptorProto = {
   server_streaming: bool;
   client_streaming: bool;
   options: Types_.s_MethodOptions option;
   output_type: string option;
   input_type: string option;
   name: string option;
 }

 let extract = Types_.extract_MethodDescriptorProto

 let mk ?server_streaming:_local0 ?client_streaming:_local1 ?options:_local2
     ?output_type:_local3 ?input_type:_local4 ?name:_local5  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg server_streaming _local0;
   Pb.setf _msg client_streaming _local1;
   Pb.setf _msg options _local2;
   Pb.setf _msg output_type _local3;
   Pb.setf _msg input_type _local4;
   Pb.setf _msg name _local5;
   _msg
end

module ServiceDescriptorProto = struct
 include Types_.Fields__ServiceDescriptorProto

 type s = Types_.s_ServiceDescriptorProto = {
   options: Types_.s_ServiceOptions option;
   method_: Types_.s_MethodDescriptorProto list;
   name: string option;
 }

 let extract = Types_.extract_ServiceDescriptorProto

 let mk ?options:_local0 ~method_:_local1 ?name:_local2  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg options _local0;
   Pb.setf _msg method_ _local1;
   Pb.setf _msg name _local2;
   _msg
end

module ReservedRange = struct
 include Types_.Fields__ReservedRange

 type s = Types_.s_ReservedRange = {
   end_: int32 option;
   start: int32 option;
 }

 let extract = Types_.extract_ReservedRange

 let mk ?end_:_local0 ?start:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg end_ _local0;
   Pb.setf _msg start _local1;
   _msg
end

module OneofOptions = struct
 include Types_.Fields__OneofOptions

 type s = Types_.s_OneofOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
 }

 let extract = Types_.extract_OneofOptions

 let mk ~uninterpreted_option:_local0  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   _msg
end

module CodeGeneratorResponse = struct
 include Types_.Fields__CodeGeneratorResponse

 type s = Types_.s_CodeGeneratorResponse = {
   file: Types_.s_File list;
   error: string option;
 }

 let extract = Types_.extract_CodeGeneratorResponse

 let mk ~file:_local0 ?error:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg file _local0;
   Pb.setf _msg error _local1;
   _msg
end

module GeneratedCodeInfo = struct
 include Types_.Fields__GeneratedCodeInfo

 type s = Types_.s_GeneratedCodeInfo = {
   annotation: Types_.s_Annotation list;
 }

 let extract = Types_.extract_GeneratedCodeInfo

 let mk ~annotation:_local0  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg annotation _local0;
   _msg
end

module CodeGeneratorRequest = struct
 include Types_.Fields__CodeGeneratorRequest

 type s = Types_.s_CodeGeneratorRequest = {
   compiler_version: Types_.s_Version option;
   proto_file: Types_.s_FileDescriptorProto list;
   parameter: string option;
   file_to_generate: string list;
 }

 let extract = Types_.extract_CodeGeneratorRequest

 let mk ?compiler_version:_local0 ~proto_file:_local1 ?parameter:_local2
     ~file_to_generate:_local3  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg compiler_version _local0;
   Pb.setf _msg proto_file _local1;
   Pb.setf _msg parameter _local2;
   Pb.setf _msg file_to_generate _local3;
   _msg
end

module EnumDescriptorProto = struct
 include Types_.Fields__EnumDescriptorProto

 type s = Types_.s_EnumDescriptorProto = {
   options: Types_.s_EnumOptions option;
   value: Types_.s_EnumValueDescriptorProto list;
   name: string option;
 }

 let extract = Types_.extract_EnumDescriptorProto

 let mk ?options:_local0 ~value:_local1 ?name:_local2  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg options _local0;
   Pb.setf _msg value _local1;
   Pb.setf _msg name _local2;
   _msg
end

module FileOptions = struct
 include Types_.Fields__FileOptions

 type s = Types_.s_FileOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   swift_prefix: string option;
   csharp_namespace: string option;
   objc_class_prefix: string option;
   cc_enable_arenas: bool;
   deprecated: bool;
   py_generic_services: bool;
   java_generic_services: bool;
   cc_generic_services: bool;
   go_package: string option;
   optimize_for: Types_.OptimizeMode.e Pb.enum;
   java_string_check_utf8: bool;
   java_generate_equals_and_hash: bool option;
   java_multiple_files: bool;
   java_outer_classname: string option;
   java_package: string option;
 }

 let extract = Types_.extract_FileOptions

 let mk ~uninterpreted_option:_local0 ?swift_prefix:_local1
     ?csharp_namespace:_local2 ?objc_class_prefix:_local3
     ?cc_enable_arenas:_local4 ?deprecated:_local5
     ?py_generic_services:_local6 ?java_generic_services:_local7
     ?cc_generic_services:_local8 ?go_package:_local9 ?optimize_for:_local10
     ?java_string_check_utf8:_local11 ?java_generate_equals_and_hash:_local12
     ?java_multiple_files:_local13 ?java_outer_classname:_local14
     ?java_package:_local15  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg swift_prefix _local1;
   Pb.setf _msg csharp_namespace _local2;
   Pb.setf _msg objc_class_prefix _local3;
   Pb.setf _msg cc_enable_arenas _local4;
   Pb.setf _msg deprecated _local5;
   Pb.setf _msg py_generic_services _local6;
   Pb.setf _msg java_generic_services _local7;
   Pb.setf _msg cc_generic_services _local8;
   Pb.setf _msg go_package _local9;
   Pb.setf _msg optimize_for _local10;
   Pb.setf _msg java_string_check_utf8 _local11;
   Pb.setf _msg java_generate_equals_and_hash _local12;
   Pb.setf _msg java_multiple_files _local13;
   Pb.setf _msg java_outer_classname _local14;
   Pb.setf _msg java_package _local15;
   _msg
end

module Annotation = struct
 include Types_.Fields__Annotation

 type s = Types_.s_Annotation = {
   end_: int32 option;
   begin_: int32 option;
   source_file: string option;
   path: int32 list;
 }

 let extract = Types_.extract_Annotation

 let mk ?end_:_local0 ?begin_:_local1 ?source_file:_local2 ~path:_local3  ()
     =
   let _msg = Pb.create T.t in
   Pb.setf _msg end_ _local0;
   Pb.setf _msg begin_ _local1;
   Pb.setf _msg source_file _local2;
   Pb.setf _msg path _local3;
   _msg
end

module OneofDescriptorProto = struct
 include Types_.Fields__OneofDescriptorProto

 type s = Types_.s_OneofDescriptorProto = {
   options: Types_.s_OneofOptions option;
   name: string option;
 }

 let extract = Types_.extract_OneofDescriptorProto

 let mk ?options:_local0 ?name:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg options _local0;
   Pb.setf _msg name _local1;
   _msg
end

module EnumValueDescriptorProto = struct
 include Types_.Fields__EnumValueDescriptorProto

 type s = Types_.s_EnumValueDescriptorProto = {
   options: Types_.s_EnumValueOptions option;
   number: int32 option;
   name: string option;
 }

 let extract = Types_.extract_EnumValueDescriptorProto

 let mk ?options:_local0 ?number:_local1 ?name:_local2  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg options _local0;
   Pb.setf _msg number _local1;
   Pb.setf _msg name _local2;
   _msg
end

module FieldDescriptorProto = struct
 include Types_.Fields__FieldDescriptorProto

 type s = Types_.s_FieldDescriptorProto = {
   options: Types_.s_FieldOptions option;
   json_name: string option;
   oneof_index: int32 option;
   default_value: string option;
   extendee: string option;
   type_name: string option;
   type_: Types_.Type.e Pb.enum option;
   label: Types_.Label.e Pb.enum option;
   number: int32 option;
   name: string option;
 }

 let extract = Types_.extract_FieldDescriptorProto

 let mk ?options:_local0 ?json_name:_local1 ?oneof_index:_local2
     ?default_value:_local3 ?extendee:_local4 ?type_name:_local5
     ?type_:_local6 ?label:_local7 ?number:_local8 ?name:_local9  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg options _local0;
   Pb.setf _msg json_name _local1;
   Pb.setf _msg oneof_index _local2;
   Pb.setf _msg default_value _local3;
   Pb.setf _msg extendee _local4;
   Pb.setf _msg type_name _local5;
   Pb.setf _msg type_ _local6;
   Pb.setf _msg label _local7;
   Pb.setf _msg number _local8;
   Pb.setf _msg name _local9;
   _msg
end

module SourceCodeInfo = struct
 include Types_.Fields__SourceCodeInfo

 type s = Types_.s_SourceCodeInfo = {
   location: Types_.s_Location list;
 }

 let extract = Types_.extract_SourceCodeInfo

 let mk ~location:_local0  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg location _local0;
   _msg
end

module FieldOptions = struct
 include Types_.Fields__FieldOptions

 type s = Types_.s_FieldOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   weak: bool;
   deprecated: bool;
   lazy_: bool;
   jstype: Types_.JSType.e Pb.enum;
   packed: bool option;
   ctype: Types_.CType.e Pb.enum;
 }

 let extract = Types_.extract_FieldOptions

 let mk ~uninterpreted_option:_local0 ?weak:_local1 ?deprecated:_local2
     ?lazy_:_local3 ?jstype:_local4 ?packed:_local5 ?ctype:_local6  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg weak _local1;
   Pb.setf _msg deprecated _local2;
   Pb.setf _msg lazy_ _local3;
   Pb.setf _msg jstype _local4;
   Pb.setf _msg packed _local5;
   Pb.setf _msg ctype _local6;
   _msg
end

module EnumValueOptions = struct
 include Types_.Fields__EnumValueOptions

 type s = Types_.s_EnumValueOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   deprecated: bool;
 }

 let extract = Types_.extract_EnumValueOptions

 let mk ~uninterpreted_option:_local0 ?deprecated:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg deprecated _local1;
   _msg
end

module UninterpretedOption = struct
 include Types_.Fields__UninterpretedOption

 type s = Types_.s_UninterpretedOption = {
   aggregate_value: string option;
   string_value: Bytes.t option;
   double_value: double option;
   negative_int_value: int64 option;
   positive_int_value: uint64 option;
   identifier_value: string option;
   name: Types_.s_NamePart list;
 }

 let extract = Types_.extract_UninterpretedOption

 let mk ?aggregate_value:_local0 ?string_value:_local1 ?double_value:_local2
     ?negative_int_value:_local3 ?positive_int_value:_local4
     ?identifier_value:_local5 ~name:_local6  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg aggregate_value _local0;
   Pb.setf _msg string_value _local1;
   Pb.setf _msg double_value _local2;
   Pb.setf _msg negative_int_value _local3;
   Pb.setf _msg positive_int_value _local4;
   Pb.setf _msg identifier_value _local5;
   Pb.setf _msg name _local6;
   _msg
end

module ExtensionRange = struct
 include Types_.Fields__ExtensionRange

 type s = Types_.s_ExtensionRange = {
   end_: int32 option;
   start: int32 option;
 }

 let extract = Types_.extract_ExtensionRange

 let mk ?end_:_local0 ?start:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg end_ _local0;
   Pb.setf _msg start _local1;
   _msg
end

module MessageOptions = struct
 include Types_.Fields__MessageOptions

 type s = Types_.s_MessageOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   map_entry: bool option;
   deprecated: bool;
   no_standard_descriptor_accessor: bool;
   message_set_wire_format: bool;
 }

 let extract = Types_.extract_MessageOptions

 let mk ~uninterpreted_option:_local0 ?map_entry:_local1 ?deprecated:_local2
     ?no_standard_descriptor_accessor:_local3
     ?message_set_wire_format:_local4  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg map_entry _local1;
   Pb.setf _msg deprecated _local2;
   Pb.setf _msg no_standard_descriptor_accessor _local3;
   Pb.setf _msg message_set_wire_format _local4;
   _msg
end

module MethodOptions = struct
 include Types_.Fields__MethodOptions

 type s = Types_.s_MethodOptions = {
   uninterpreted_option: Types_.s_UninterpretedOption list;
   idempotency_level: Types_.IdempotencyLevel.e Pb.enum;
   deprecated: bool;
 }

 let extract = Types_.extract_MethodOptions

 let mk ~uninterpreted_option:_local0 ?idempotency_level:_local1
     ?deprecated:_local2  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg uninterpreted_option _local0;
   Pb.setf _msg idempotency_level _local1;
   Pb.setf _msg deprecated _local2;
   _msg
end

module FileDescriptorProto = struct
 include Types_.Fields__FileDescriptorProto

 type s = Types_.s_FileDescriptorProto = {
   syntax: string option;
   source_code_info: Types_.s_SourceCodeInfo option;
   options: Types_.s_FileOptions option;
   extension: Types_.s_FieldDescriptorProto list;
   service: Types_.s_ServiceDescriptorProto list;
   enum_type: Types_.s_EnumDescriptorProto list;
   message_type: Types_.s_DescriptorProto list;
   weak_dependency: int32 list;
   public_dependency: int32 list;
   dependency: string list;
   package: string option;
   name: string option;
 }

 let extract = Types_.extract_FileDescriptorProto

 let mk ?syntax:_local0 ?source_code_info:_local1 ?options:_local2
     ~extension:_local3 ~service:_local4 ~enum_type:_local5
     ~message_type:_local6 ~weak_dependency:_local7
     ~public_dependency:_local8 ~dependency:_local9 ?package:_local10
     ?name:_local11  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg syntax _local0;
   Pb.setf _msg source_code_info _local1;
   Pb.setf _msg options _local2;
   Pb.setf _msg extension _local3;
   Pb.setf _msg service _local4;
   Pb.setf _msg enum_type _local5;
   Pb.setf _msg message_type _local6;
   Pb.setf _msg weak_dependency _local7;
   Pb.setf _msg public_dependency _local8;
   Pb.setf _msg dependency _local9;
   Pb.setf _msg package _local10;
   Pb.setf _msg name _local11;
   _msg
end

module NamePart = struct
 include Types_.Fields__NamePart

 type s = Types_.s_NamePart = {
   is_extension: bool;
   name_part: string;
 }

 let extract = Types_.extract_NamePart

 let mk ~is_extension:_local0 ~name_part:_local1  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg is_extension _local0;
   Pb.setf _msg name_part _local1;
   _msg
end

module Version = struct
 include Types_.Fields__Version

 type s = Types_.s_Version = {
   suffix: string option;
   patch: int32 option;
   minor: int32 option;
   major: int32 option;
 }

 let extract = Types_.extract_Version

 let mk ?suffix:_local0 ?patch:_local1 ?minor:_local2 ?major:_local3  () =
   let _msg = Pb.create T.t in
   Pb.setf _msg suffix _local0;
   Pb.setf _msg patch _local1;
   Pb.setf _msg minor _local2;
   Pb.setf _msg major _local3;
   _msg
end

module OptimizeMode =
struct
  module T = struct
    type e = Types_.OptimizeMode.e
    let __map = [
       1l, `SPEED;
       2l, `CODE_SIZE;
       3l, `LITE_RUNTIME;
    ]
    let of_value x = List.assoc x __map
    let to_value x = rassoc x __map
  end
  include Types_.OptimizeMode__constants
  
end

module Label =
struct
  module T = struct
    type e = Types_.Label.e
    let __map = [
       1l, `LABEL_OPTIONAL;
       2l, `LABEL_REQUIRED;
       3l, `LABEL_REPEATED;
    ]
    let of_value x = List.assoc x __map
    let to_value x = rassoc x __map
  end
  include Types_.Label__constants
  
end

module Type =
struct
  module T = struct
    type e = Types_.Type.e
    let __map = [
       1l, `TYPE_DOUBLE;
       2l, `TYPE_FLOAT;
       3l, `TYPE_INT64;
       4l, `TYPE_UINT64;
       5l, `TYPE_INT32;
       6l, `TYPE_FIXED64;
       7l, `TYPE_FIXED32;
       8l, `TYPE_BOOL;
       9l, `TYPE_STRING;
       10l, `TYPE_GROUP;
       11l, `TYPE_MESSAGE;
       12l, `TYPE_BYTES;
       13l, `TYPE_UINT32;
       14l, `TYPE_ENUM;
       15l, `TYPE_SFIXED32;
       16l, `TYPE_SFIXED64;
       17l, `TYPE_SINT32;
       18l, `TYPE_SINT64;
    ]
    let of_value x = List.assoc x __map
    let to_value x = rassoc x __map
  end
  include Types_.Type__constants
  
end

module JSType =
struct
  module T = struct
    type e = Types_.JSType.e
    let __map = [
       0l, `JS_NORMAL;
       1l, `JS_STRING;
       2l, `JS_NUMBER;
    ]
    let of_value x = List.assoc x __map
    let to_value x = rassoc x __map
  end
  include Types_.JSType__constants
  
end

module IdempotencyLevel =
struct
  module T = struct
    type e = Types_.IdempotencyLevel.e
    let __map = [
       0l, `IDEMPOTENCY_UNKNOWN;
       1l, `NO_SIDE_EFFECTS;
       2l, `IDEMPOTENT;
    ]
    let of_value x = List.assoc x __map
    let to_value x = rassoc x __map
  end
  include Types_.IdempotencyLevel__constants
  
end

module CType =
struct
  module T = struct
    type e = Types_.CType.e
    let __map = [
       0l, `STRING;
       1l, `CORD;
       2l, `STRING_PIECE;
    ]
    let of_value x = List.assoc x __map
    let to_value x = rassoc x __map
  end
  include Types_.CType__constants
  
end

